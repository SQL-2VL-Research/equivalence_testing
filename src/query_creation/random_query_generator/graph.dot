# Structure is ALWAYS as follows:
# 1. General rule is place function definitions inside their own subgraphs.
# 2. Functional node begins from the node_name node.

# 3. Function definitions look as follows:
# 1) Node with parameters:
# subgraph def_{node_name} {
#     {node_name} [
#         TYPES = "[{type_name}, ...]" OR "[any]" OR "[known]" OR "[compatible]",
#         TYPE = "{type_name}, ..." OR "known",
#         MOD = "[{mod_name}, ...]",
#         ...
#     ]
#     ...
# }
# TYPE, TYPES and MOD in definitions are only for type-checking in definitions.
# all specified types of modifiers (TYPE, TYPES, MOD) are required to be passed by caller
# compatible is just the same type for not

# 4. Optional node (with a question mark at the end):
# {node_name} [OPTIONAL="t"]

# 5. Exit a callable node:
# EXIT_{node_name} [label="EXIT {node_label}"]

# 6. Call a callable node with params:
# call{caller_num}_{node_name} [TYPES={...}, MOD={...}, ...]
# ... -> call...
# there can be multiple callers, so each caller should have a unique id
# values of TYPES and MOD are exact mathes to those in definition

# 7. Call a callable node without params:
# call{caller_num}_{node_name} [...]
# ... -> call...

# 8. These are ignored:
# 1) ... -> ... [color=none]
# 2) Graphviz params in [] (label, shape...)

# 9. Define a node before referencing it:
# FROM []
# Query -> FROM

# 10. Don't do this:
# ... -> ... -> ...

# 11. subgraph ignore {} is completely ignored

# 12. Do NOT use block comments /* */

digraph G {
    subgraph def_Query {
        Query [TYPES="[any]", MOD="[single value]", label="Query\ntypes(ordered)=[...]\nmodif.=[SINGLE VALUE]", shape=octagon]
        EXIT_Query [label="EXIT Query"]

        FROM []
        Query -> FROM

        FROM_multiple_relations [label="multiple relations"]

        Table []
        FROM -> Table
        Table -> FROM_multiple_relations
        FROM_multiple_relations -> Table

        call0_Query [label="Query", shape=rectangle, TYPES="[any]", MOD="[]"]
        FROM -> call0_Query
        call0_Query -> FROM_multiple_relations
        FROM_multiple_relations -> call0_Query

        EXIT_FROM [label="EXIT FROM"]
        FROM_multiple_relations -> EXIT_FROM

        WHERE [label="WHERE"]
        EXIT_FROM -> WHERE

        call0_VAL_3 [label="3VL Value", shape=rectangle]
        WHERE -> call0_VAL_3

        SELECT []
        EXIT_WHERE [label="EXIT WHERE"]
        call0_VAL_3 -> EXIT_WHERE
        EXIT_FROM -> EXIT_WHERE

        SELECT []
        call0_Group_by [label = "GROUP BY Statement", shape=rectangle]
        EXIT_WHERE -> SELECT
        EXIT_WHERE -> call0_Group_by
        call0_Group_by -> SELECT
        
        SELECT_ALL [label = "ALL"]
        SELECT_DISTINCT [label = "DISTINCT"]
        SELECT_TIES [label = "WITH TIES"]
        SELECT_PERCENT [label = "PERCENT"]
        SELECT_TOP [label = "TOP"]
        TOP_EXPR [TYPES="[numeric]", label="TOP expr\n TYPES: numeric"]
        SELECT_WITH_TIES [label = "WITH TIES"]
        SELECT_distinct_end [label = ";"]
        SELECT_percent_end [label = ";"]
        SELECT -> SELECT_DISTINCT
        SELECT -> SELECT_ALL
        SELECT_DISTINCT -> SELECT_distinct_end
        SELECT_ALL -> SELECT_distinct_end
        SELECT_distinct_end -> SELECT_TOP
        SELECT_TOP -> TOP_EXPR
        TOP_EXPR -> SELECT_PERCENT
        SELECT_PERCENT -> SELECT_percent_end
        TOP_EXPR -> SELECT_percent_end
        SELECT_percent_end -> SELECT_WITH_TIES


        call0_SELECT_projection [label="generate projection", shape=rectangle]
        SELECT_WITH_TIES -> call0_SELECT_projection
        SELECT_distinct_end -> call0_SELECT_projection
        SELECT_percent_end -> call0_SELECT_projection
        
        # ===============================================
        
        EXIT_SELECT [label = "EXIT SELECT"]

    }
    
    subgraph def_VAL_3 {
        VAL_3 [shape=rectangle, label="3VL Value"]
        EXIT_VAL_3 [shape=rectangle, label="EXIT 3VL Value"]

        IsNull [label="IS NULL"]
        call0_types_all [label="TYPES: ALL", shape=rectangle]
        VAL_3 -> IsNull
        IsNull -> call0_types_all
        IsNull_not [label="NOT"]
        IsNull -> IsNull_not
        IsNull_not -> call0_types_all
        call0_types_all -> EXIT_VAL_3

        IsDistinctFrom [label="IS DISTINCT FROM"]
        call1_types_all [label="TYPES: ALL", shape=rectangle]
        IsDistinctNOT [label="NOT"]
        DISTINCT []
        call21_types [TYPES="[compatible]", label="TYPES: [compatible]", shape=rectangle]
        VAL_3 -> IsDistinctFrom
        IsDistinctFrom -> call1_types_all
        call1_types_all -> IsDistinctNOT
        IsDistinctNOT -> DISTINCT
        call1_types_all -> DISTINCT
        DISTINCT -> call21_types
        call21_types -> EXIT_VAL_3

        Exists_not [label="NOT"]
        Exists [label="EXISTS"]
        call2_Query [TYPES="[any]", MOD="[]", label="Query", shape=rectangle]
        VAL_3 -> Exists
        Exists -> call2_Query
        call2_Query -> EXIT_VAL_3
        Exists -> Exists_not
        Exists_not -> call2_Query

        InList[label="IN [list expr]"]
        InListNot [label="NOT"]
        InListIn [label="IN"]
        VAL_3 -> InList
        call2_types_all [label="TYPES: ALL", shape=rectangle]
        InList -> call2_types_all
        call2_types_all -> InListNot
        InListNot -> InListIn
        call2_types_all -> InListIn
        call1_list_expr [TYPES="[compatible]", label="list expr\nTYPES: [compatible]", shape=rectangle]
        InListIn -> call1_list_expr
        call1_list_expr -> EXIT_VAL_3

        InSubquery[label="IN [subquery]"]
        InSubqueryNot [label="NOT"]
        InSubqueryIn [label="IN"]
        call3_types_all [label="TYPES: ALL", shape=rectangle]
        VAL_3 -> InSubquery
        InSubquery -> call3_types_all
        call3_types_all -> InSubqueryNot
        InSubqueryNot -> InSubqueryIn
        call3_types_all -> InSubqueryIn
        call3_Query [TYPES="[compatible]", MOD="[]", label="Query\nTYPE: [compatible]", shape=rectangle]
        InSubqueryIn -> call3_Query
        call3_Query -> EXIT_VAL_3

        Between[label="BETWEEN . AND ."]
        BetweenBetween [label="BETWEEN"]
        BetweenBetweenAnd [label="AND"]
        VAL_3 -> Between
        call4_types_all [label="TYPES: ALL", shape=rectangle]
        Between -> call4_types_all
        call4_types_all -> BetweenBetween
        call22_types [TYPES="[compatible]", label="TYPES: [compatible]", shape=rectangle]
        BetweenBetween -> call22_types
        call22_types -> BetweenBetweenAnd
        call23_types [TYPES="[compatible]", label="TYPES: [compatible]", shape=rectangle]
        BetweenBetweenAnd -> call23_types
        call23_types -> EXIT_VAL_3

        BinaryComp[label="CMP"]
        BinaryCompLess [label="<"]
        BinaryCompEqual [label="="]
        BinaryCompLessEqual [label="<="]
        BinaryCompUnEqual [label="<>"]
        VAL_3 -> BinaryComp
        call5_types_all [label="TYPES: ALL", shape=rectangle]
        BinaryComp -> call5_types_all
        call24_types [TYPES="[compatible]", label="TYPES: [compatible]", shape=rectangle]
        call5_types_all -> BinaryCompLess
        BinaryCompLess -> call24_types
        call5_types_all -> BinaryCompEqual
        BinaryCompEqual -> call24_types
        call5_types_all -> BinaryCompLessEqual
        BinaryCompLessEqual -> call24_types
        call5_types_all -> BinaryCompUnEqual
        BinaryCompUnEqual -> call24_types
        call24_types -> EXIT_VAL_3

        AnyAll[label="ANY / ALL"]
        AnyAllSelectOp[label="select op."]
        AnyAllLess [label="<"]
        AnyAllEqual [label="="]
        AnyAllLessEqual [label="<="]
        AnyAllUnEqual [label="<>"]
        AnyAllSelectIter[label="select iterable"]
        AnyAllAnyAll[label="select ANY/ALL"]
        AnyAllAnyAllAny[label="ANY"]
        AnyAllAnyAllAll[label="ALL"]
        VAL_3 -> AnyAll
        call2_list_expr [TYPES="[any]", label="list expr\nTYPES: ALL", shape=rectangle]
        AnyAll -> call2_list_expr
        call2_list_expr -> AnyAllSelectOp
        call6_types_all[label="TYPES: ALL", shape=rectangle]
        AnyAll -> call6_types_all
        call6_types_all -> AnyAllSelectOp
        AnyAllSelectOp -> AnyAllLess
        AnyAllLess -> AnyAllSelectIter
        AnyAllSelectOp -> AnyAllEqual
        AnyAllEqual -> AnyAllSelectIter
        AnyAllSelectOp -> AnyAllLessEqual
        AnyAllLessEqual -> AnyAllSelectIter
        AnyAllSelectOp -> AnyAllUnEqual
        AnyAllUnEqual -> AnyAllSelectIter
        call4_Query [TYPES="[compatible]", label="Query\nTYPE: [compatible]", shape=rectangle]
        AnyAllSelectIter -> call4_Query
        call4_Query -> AnyAllAnyAll
        call1_array [TYPES="[compatible]", label="array\nTYPE: [compatible]", shape=rectangle]
        AnyAllSelectIter -> call1_array
        call1_array -> AnyAllAnyAll
        AnyAllAnyAll -> AnyAllAnyAllAny
        AnyAllAnyAllAny -> EXIT_VAL_3
        AnyAllAnyAll -> AnyAllAnyAllAll
        AnyAllAnyAllAll -> EXIT_VAL_3

        BinaryStringLike[label="LIKE"]
        BinaryStringLikeNot [label="NOT"]
        BinaryStringLikeIn [label="LIKE"]
        VAL_3 -> BinaryStringLike
        call25_types [TYPES="[string]", label="TYPES: string", shape=rectangle]
        BinaryStringLike -> call25_types
        call25_types -> BinaryStringLikeNot
        BinaryStringLikeNot -> BinaryStringLikeIn
        call25_types -> BinaryStringLikeIn
        call26_types [TYPES="[string]", label="TYPES: string", shape=rectangle]
        BinaryStringLikeIn -> call26_types
        call26_types -> EXIT_VAL_3

        BinaryBooleanOpV3[label="bool op."]
        BinaryBooleanOpV3AND [label="AND"]
        BinaryBooleanOpV3OR [label="OR"]
        BinaryBooleanOpV3XOR [label="XOR"]
        VAL_3 -> BinaryBooleanOpV3
        call27_types [TYPES="[3VL Value]", label="TYPES: 3VL Value", shape=rectangle]
        BinaryBooleanOpV3 -> call27_types
        call27_types -> BinaryBooleanOpV3AND
        call28_types [TYPES="[compatible]", label="TYPES: [compatible]", shape=rectangle]
        BinaryBooleanOpV3AND -> call28_types
        call27_types -> BinaryBooleanOpV3OR
        BinaryBooleanOpV3OR -> call28_types
        call27_types -> BinaryBooleanOpV3XOR
        BinaryBooleanOpV3XOR -> call28_types
        call28_types -> EXIT_VAL_3

        true []
        VAL_3 -> true
        true -> EXIT_VAL_3
        false []
        VAL_3 -> false
        false -> EXIT_VAL_3

        Nested_VAL_3[label="([expr])"]
        VAL_3 -> Nested_VAL_3
        call29_types [TYPES="[3VL Value]", label="TYPES: 3VL Value", shape=rectangle]
        Nested_VAL_3 -> call29_types
        call29_types -> EXIT_VAL_3

        UnaryNot_VAL_3[label="NOT"]
        call30_types [TYPES="[3VL Value]", label="TYPES: 3VL Value", shape=rectangle]
        VAL_3 -> UnaryNot_VAL_3
        UnaryNot_VAL_3 -> call30_types
        call30_types -> EXIT_VAL_3
    }

    subgraph def_numeric {
        numeric [shape=rectangle, label="numeric"]
        EXIT_numeric [label="EXIT numeric"]
        EXIT_VAL_3 -> numeric [color=none]

        numeric_literal[label="literal"]
        numeric -> numeric_literal
        numeric_literal_int[label="random int"]
        numeric_literal -> numeric_literal_int
        numeric_literal_int -> EXIT_numeric
        numeric_literal_float[label="random float"]
        numeric_literal -> numeric_literal_float
        numeric_literal_float -> EXIT_numeric

        BinaryNumericOp[label="binary op."]
        numericRight [label="TYPES: numeric", shape=rectangle]
        numeric -> BinaryNumericOp
        binary_numeric_left [label="TYPES: numeric", shape=rectangle]
        BinaryNumericOp -> binary_numeric_left
        binary_numeric_plus [label="+"]
        binary_numeric_left -> binary_numeric_plus
        binary_numeric_plus -> numericRight
        binary_numeric_minus [label="-"]
        binary_numeric_left -> binary_numeric_minus
        binary_numeric_minus -> numericRight
        binary_numeric_mul [label="*"]
        binary_numeric_left -> binary_numeric_mul
        binary_numeric_mul -> numericRight
        binary_numeric_div [label="/"]
        binary_numeric_left -> binary_numeric_div
        binary_numeric_div -> numericRight
        binary_numeric_bin_or [label="|"]
        binary_numeric_left -> binary_numeric_bin_or
        binary_numeric_bin_or -> numericRight
        binary_numeric_bin_and [label="&"]
        binary_numeric_left -> binary_numeric_bin_and
        binary_numeric_bin_and -> numericRight
        binary_numeric_bin_xor [label="^"]
        binary_numeric_left -> binary_numeric_bin_xor
        binary_numeric_bin_xor -> numericRight
        numericRight -> EXIT_numeric

        UnaryNumericOp [label="unary op."]
        call1_types [TYPES="[numeric]", label="TYPES: numeric"]
        numeric -> UnaryNumericOp
        unary_numeric_plus[label="+"]
        UnaryNumericOp -> unary_numeric_plus
        unary_numeric_plus -> call1_types
        unary_numeric_minus[label="-"]
        UnaryNumericOp -> unary_numeric_minus
        unary_numeric_minus -> call1_types
        unary_numeric_bin_not [label="~"]
        UnaryNumericOp -> unary_numeric_bin_not
        unary_numeric_bin_not -> call1_types
        unary_numeric_sq_root [label="|/"]
        UnaryNumericOp -> unary_numeric_sq_root
        unary_numeric_sq_root -> call1_types
        unary_numeric_cub_root [label="||/"]
        UnaryNumericOp -> unary_numeric_cub_root
        unary_numeric_cub_root -> call1_types
        unary_numeric_postfix_fact [label="!"]
        UnaryNumericOp -> unary_numeric_postfix_fact
        unary_numeric_postfix_fact -> call1_types
        unary_numeric_prefix_fact [label="!!"]
        UnaryNumericOp -> unary_numeric_prefix_fact
        unary_numeric_prefix_fact -> call1_types
        unary_numeric_abs [label="@"]
        UnaryNumericOp -> unary_numeric_abs
        unary_numeric_abs -> call1_types
        call1_types -> EXIT_numeric

        numeric_string_Position[label="POSITION([expr] in [expr])"]
        numeric -> numeric_string_Position
        call2_types [TYPES="[string]", label="TYPES: string", shape=rectangle]
        numeric_string_Position -> call2_types
        string_position_in [label="in"]
        call2_types -> string_position_in
        call3_types [TYPES="[string]", label="TYPES: string", shape=rectangle]
        string_position_in -> call3_types
        call3_types -> EXIT_numeric

        Nested_numeric[label="([expr])"]
        numeric -> Nested_numeric
        call4_types [TYPES="[numeric]", label="TYPES: numeric", shape=rectangle]
        Nested_numeric -> call4_types
        call4_types -> EXIT_numeric
    }

    subgraph def_string {
        string [label="string", shape=rectangle]
        EXIT_string [label="EXIT string"]
        EXIT_numeric -> string [color=none]

        string_literal [label="random string literal"]
        string -> string_literal
        string_literal -> EXIT_string

        string_trim[label="TRIM"]
        string -> string_trim
        call5_types [TYPES="[string]", label="TYPES: string"]
        string_trim -> call5_types
        call6_types[TYPES="[string]", label="TYPES: string"]
        string_trim -> call6_types
        BOTH []
        call6_types -> BOTH
        BOTH -> call5_types
        LEADING []
        call6_types -> LEADING
        LEADING -> call5_types
        TRAILING []
        call6_types -> TRAILING
        TRAILING -> call5_types
        call5_types -> EXIT_string

        string_concat [label="concatenation"]
        string -> string_concat
        call7_types [TYPES="[string]", label="TYPES: string"]
        string_concat -> call7_types
        string_concat_concat [label="||"]
        call7_types -> string_concat_concat
        call8_types[TYPES="[string]", label="TYPES: string"]
        string_concat_concat -> call8_types
        call8_types -> EXIT_string

        string_substring[label="substring"]
        string -> string_substring
        call9_types[TYPES="[string]", label="TYPES: string"]
        string_substring -> call9_types
        string_substr_numeric_from_from[label="from"]
        call9_types -> string_substr_numeric_from_from
        call10_types [TYPES="[numeric]", label="TYPES: numeric"]
        string_substr_numeric_from_from -> call10_types
        call10_types -> EXIT_string
        string_substr_numeric_len_len [label="length"]
        call10_types -> string_substr_numeric_len_len
        call11_types [TYPES="[numeric]", label="TYPES: numeric"]
        string_substr_numeric_len_len -> call11_types
        call11_types -> EXIT_string
    }

    subgraph def_types {
        types [TYPES="[numeric, 3VL Value, array, list expr, string]", label="TYPE(S) (generic):\ntypes=[numeric?, 3VL Value?, array?, list expr?, string?]", shape=octagon]
        EXIT_types [label="EXIT GENERIC TYPE(S)", shape=rectangle]

        types_select_type[label="type := "]
        types_select_type_end[label=";"]
        types -> types_select_type
        types_select_type_numeric[OPTIONAL="t", label="numeric?"]
        types_select_type -> types_select_type_numeric
        types_select_type_numeric -> types_select_type_end
        types_select_type_3vl[OPTIONAL="t", label="3VL Value?"]
        types_select_type -> types_select_type_3vl
        types_select_type_3vl -> types_select_type_end
        types_select_type_array[OPTIONAL="t", label="array?"]
        types_select_type -> types_select_type_array
        types_select_type_array -> types_select_type_end
        types_select_type_list_expr[OPTIONAL="t", label="list expr?"]
        types_select_type -> types_select_type_list_expr
        types_select_type_list_expr -> types_select_type_end
        types_select_type_string[OPTIONAL="t", label="string?"]
        types_select_type -> types_select_type_string
        types_select_type_string -> types_select_type_end

        call0_column_spec [TYPE="known", label="column specifier\nTYPE: type", shape=rectangle]
        types_select_type_end -> call0_column_spec
        call0_column_spec -> EXIT_types

        call1_Query [TYPES="[known]", MOD="[single value]", label="Query\nmodif.: SINGLE VALUE\nTYPE: type", shape=rectangle]
        types_select_type_end -> call1_Query
        call1_Query -> EXIT_types

        types_null [label="null"]
        types -> types_null
        types_null -> EXIT_types

        call0_numeric [OPTIONAL="t", label="numeric?", shape=rectangle]
        types -> call0_numeric
        call0_numeric -> EXIT_types

        call1_VAL_3 [OPTIONAL="t", label="3VL Value?", shape=rectangle]
        types -> call1_VAL_3
        call1_VAL_3 -> EXIT_types

        call0_string [OPTIONAL="t", label="string?", shape=rectangle]
        types -> call0_string
        call0_string -> EXIT_types

        call0_list_expr [OPTIONAL="t", TYPES="[known]", label="list expr?\nTYPES: [...types]", shape=rectangle]
        types -> call0_list_expr
        call0_list_expr -> EXIT_types

        call0_array [OPTIONAL="t", TYPES="[known]", label="array?\nTYPES: [...types]", shape=rectangle]
        types -> call0_array
        call0_array -> EXIT_types
    }

    subgraph def_types_all {
        types_all [label="TYPES: ALL", shape=rectangle]
        EXIT_types_all [label="EXIT TYPES: ALL", shape=rectangle]
        EXIT_types -> types_all [color=none]

        call0_types [TYPES="[numeric, 3VL Value, array, list expr, string]", label="TYPES: numeric, 3VL Value, array, list expr, string", shape=rectangle]
        types_all -> call0_types
        call0_types -> EXIT_types_all
    }

    subgraph def_column_spec {
        column_spec [TYPE="numeric, 3VL Value, string, array", label="column specifier\ntype = numeric | 3VL Value | string | array", shape=octagon]
        EXIT_column_spec [label="EXIT column specifier", shape=rectangle]
        EXIT_types_all -> column_spec [color=none]

        qualified_name [label="Qualified column name of type: type"]
        column_spec -> qualified_name
        qualified_name -> EXIT_column_spec
        unqualified_name [label="Unqualified column name of type: type"]
        column_spec -> unqualified_name
        unqualified_name -> EXIT_column_spec
    }

    subgraph def_array {
        array [TYPES="[numeric, 3VL Value, string, array]", label="array\ntypes = [numeric?, 3VL Value?, string?, array?]", shape=octagon]
        EXIT_array[label="EXIT array"]
        EXIT_column_spec -> array[color=none]

        call12_types [OPTIONAL="t", TYPES="[numeric]", label="TYPE: numeric?", shape=rectangle]
        call12_types -> call12_types
        array -> call12_types
        call12_types -> EXIT_array

        call13_types [OPTIONAL="t", TYPES="[3VL Value]", label="TYPE: 3VL Value?", shape=rectangle]
        call13_types -> call13_types
        array -> call13_types
        call13_types -> EXIT_array

        call31_types [OPTIONAL="t", TYPES="[string]", label="TYPE: string?", shape=rectangle]
        call31_types -> call31_types
        array -> call31_types
        call31_types -> EXIT_array

        call14_types [OPTIONAL="t", TYPES="[array]", label="TYPE: array?", shape=rectangle]
        call14_types -> call14_types
        array -> call14_types
        call14_types -> EXIT_array

        call15_types[OPTIONAL="t", TYPES="[list expr]", label="TYPE: list expr?", shape=rectangle]
        call15_types -> call15_types
        array -> call15_types
        call15_types -> EXIT_array
    }

    subgraph def_list_expr {
        list_expr[TYPES="[numeric, 3VL Value, string, list expr, array]", label="list expr\ntypes = [numeric?, 3VL Value?, string?, list expr?, array?]", shape=octagon]
        EXIT_list_expr[label="EXIT list expr"]
        EXIT_array -> list_expr[color=none]

        list_expr_element [label="list expr element"]
        list_expr_element_exit[label="EXIT list expr element"]
        list_expr -> list_expr_element

        call16_types [OPTIONAL="t", TYPES="[numeric]", label="TYPE: numeric?", shape=rectangle]
        list_expr_element -> call16_types
        call16_types -> list_expr_element_exit

        call17_types [OPTIONAL="t", TYPES="[3VL Value]", label="TYPE: 3VL Value?", shape=rectangle]
        list_expr_element -> call17_types
        call17_types -> list_expr_element_exit

        call18_types [OPTIONAL="t", TYPES="[string]", label="TYPE: string?", shape=rectangle]
        list_expr_element -> call18_types
        call18_types -> list_expr_element_exit

        call19_types [OPTIONAL="t", TYPES="[list expr]", label="TYPE: list expr?", shape=rectangle]
        list_expr_element -> call19_types
        call19_types -> list_expr_element_exit

        call20_types [OPTIONAL="t", TYPES="[array]", label="TYPE: array?", shape=rectangle]
        list_expr_element -> call20_types
        call20_types -> list_expr_element_exit

        list_expr_element_exit -> list_expr_element
        list_expr_element_exit -> EXIT_list_expr
    }

    subgraph def_group_by {
        GROUP_BY [label="GROUP BY", shape=rectangle]
        column_expression [label="column expression"]
        Grouping_rollup [label="rollup"]
        Grouping_cube [label="cube"]
        Grouping_set [label="Grouping set"]
        group_by_col_list [label="array of columns\nTYPES: STRING", TYPES="string"]
        //columns must appear in FROM, but not necesserily in SELECT
        GROUP_BY -> group_by_col_list
        GROUP_BY -> Grouping_rollup
        GROUP_BY -> Grouping_cube
        GROUP_BY -> Grouping_set
        
        Grouping_set -> group_by_col_list
        Grouping_set -> Grouping_cube
        Grouping_set -> Grouping_rollup
        
        Grouping_rollup -> group_by_col_list
        Grouping_cube -> group_by_col_list
        group_by_col_list -> column_expression
        column_expression -> group_by_col_list
        
        EXIT_GROUP_BY [label="EXIT GROUP BY"]
        column_expression -> EXIT_GROUP_BY
        
        EXIT_SELECT -> GROUP_BY [color=none] # visual

        
    } 

    subgraph def_SELECT_projection {

        SELECT_projection [shape=rectangle, label = "SELECT projection"]
        EXIT_SELECT_projection [label="EXIT SELECT projection"]
        wildcard []
        SELECT_expr [label="expr"]
        SELECT_list_element [label="SELECT list element"]
        EXIT_SELECT_list_element [label="EXIT SELECT list element"]
        SELECT_projection -> SELECT_list_element
        SELECT_list_element -> wildcard
        SELECT_list_element -> SELECT_expr
        wildcard -> EXIT_SELECT_list_element
        EXIT_SELECT_list_element -> EXIT_SELECT_projection
        EXIT_SELECT_list_element -> SELECT_list_element
        
        expr_with_alias [label="expression with alias"]
        unnamed_expr [label="unnamed expression"]
        qualified_wildcard[label = "qualified wildcard"]
        SELECT_expr -> expr_with_alias
        SELECT_expr -> qualified_wildcard
        SELECT_expr -> unnamed_expr
        
        
//===========================

  
        EXIT_GROUP_BY -> SELECT_projection [color=none] # visual

    }

    subgraph def_aggregate_function {
        aggr_function [label="aggregate function"]
        EXIT_aggr [label="EXIT aggregate function"]
      
        AVG[label="AVG\nTYPES: [numeric]", TYPES="[numeric]"]
        call32_types [OPTIONAL="t", TYPES="[compatible]", label="TYPE: [compatible]?", shape=rectangle]
        call0_nested_function[label="nested function, TYPES: [compatible]", TYPES="[compatible]", shape=rectangle]
        AVG -> call0_nested_function 
        call0_nested_function -> EXIT_aggr
        aggr_function -> AVG
        AVG -> call32_types 
        call32_types -> EXIT_aggr

        CHECKSUM_AGG[label="CHECKSUM_AGG\nTYPES: [numeric]", TYPES="[numeric]"]
        call33_types [OPTIONAL="t", TYPES="[compatible]", label="TYPE: [compatible]?", shape=rectangle]
        call1_nested_function[label="nested function, TYPES: [compatible]", TYPES="[compatible]", shape=rectangle]
        CHECKSUM_AGG -> call1_nested_function 
        call1_nested_function -> EXIT_aggr
        aggr_function -> CHECKSUM_AGG
        CHECKSUM_AGG -> call33_types 
        call33_types -> EXIT_aggr
        
        COUNT[label="COUNT\nTYPES: [numeric]", TYPES="[numeric]"]
        call34_types [OPTIONAL="t", TYPES="[compatible]", label="TYPE: [compatible]?", shape=rectangle]
        COUNT_wildcard [label="wildcard"]
        call2_nested_function [label="nested function, TYPES: [compatible]", TYPES="[compatible]", shape=rectangle]
        COUNT -> call2_nested_function 
        call2_nested_function -> EXIT_aggr
        aggr_function -> COUNT
        COUNT -> call34_types
        COUNT -> COUNT_wildcard
        COUNT_wildcard -> EXIT_aggr
        call34_types -> EXIT_aggr
        
        COUNT_BIG[label="COUNT_BIG\nTYPES: [numeric]", TYPES="[numeric]"]
        call35_types [OPTIONAL="t", TYPES="[compatible]", label="TYPE: [compatible]?", shape=rectangle]
        COUNT_BIG_wildcard [label="wildcard"]
        call3_nested_function[label="nested function, TYPES: [compatible]", TYPES="[compatible]", shape=rectangle]
        COUNT_BIG -> call3_nested_function 
        call3_nested_function -> EXIT_aggr
        aggr_function -> COUNT_BIG
        COUNT_BIG -> call35_types
        COUNT_BIG -> COUNT_BIG_wildcard
        COUNT_BIG_wildcard -> EXIT_aggr
        call35_types -> EXIT_aggr

        MAX[label="MAX\nTYPES: SAME", TYPES="SAME"]
        call36_types [OPTIONAL="t", TYPES="[ANY]", label="TYPE: ANY", shape=rectangle]
        call4_nested_function[label="nested function, TYPES: ANY", TYPES="ANY", shape=rectangle]
        MAX -> call4_nested_function 
        call4_nested_function -> EXIT_aggr
        aggr_function -> MAX
        MAX -> call36_types 
        call36_types -> EXIT_aggr

        MIN[label="MIN\nTYPES: SAME", TYPES="SAME"]
        call37_types [OPTIONAL="t", TYPES="[ANY]", label="TYPE: [ANY]", shape=rectangle]
        call5_nested_function[label="nested function, TYPES: ANY", TYPES="ANY", shape=rectangle]
        MIN -> call5_nested_function 
        call5_nested_function -> EXIT_aggr
        aggr_function -> MIN
        MIN -> call37_types 
        call37_types -> EXIT_aggr
    
        STDDEV[label="STDDEV\nTYPES: [float]", TYPES="[float]"]
        call38_types [OPTIONAL="t", TYPES="[compatible]", label="TYPE: [compatible]?", shape=rectangle]
        call6_nested_function [label="nested function, TYPES: [compatible]", TYPES="[compatible]", shape=rectangle]
        STDDEV -> call6_nested_function 
        call6_nested_function -> EXIT_aggr
        aggr_function -> STDDEV
        STDDEV -> call38_types
        call38_types -> EXIT_aggr
    
        STDEVP[label="STDEVP\nTYPES: [float]", TYPES="[float]"]
        call39_types [OPTIONAL="t", TYPES="[compatible]", label="TYPE: [compatible]?", shape=rectangle]
        call7_nested_function [label="nested function, TYPES: [compatible]", TYPES="[compatible]", shape=rectangle]
        STDEVP -> call7_nested_function 
        call7_nested_function -> EXIT_aggr
        aggr_function -> STDEVP
        STDEVP -> call39_types
        call39_types -> EXIT_aggr

        STRING_AGG[label="STRING_AGG\nTYPES: [string]", TYPES="[string]"]
        call40_types [OPTIONAL="t", TYPES="[ANY]", label="TYPE: [ANY]?", shape=rectangle]
        STRING_AGG_arg [label="argument"]
        separator [label="separator\nTYPES: [string]",TYPES="[string]"]
        STRING_AGG -> separator
        separator -> STRING_AGG_arg
        call8_nested_function [label="nested function, TYPES: [ANY]", TYPES="[ANY]", shape=rectangle]
        STRING_AGG_arg -> call8_nested_function 
        call40_nested_function -> EXIT_aggr
        aggr_function -> STRING_AGG
        STRING_AGG_arg -> call40_types
        call40_types -> EXIT_aggr

        SUM[label="SUM\nTYPES: numeric", TYPES="[numeric]"]
        call41_types [OPTIONAL="t", TYPES="[compatible]", label="TYPE: [compatible]?", shape=rectangle]
        call8_nested_function [label="nested function, TYPES: [compatible]", TYPES="[compatible]", shape=rectangle]
        SUM -> call8_nested_function 
        call8_nested_function -> EXIT_aggr
        aggr_function -> SUM
        SUM -> call41_types
        call41_types -> EXIT_aggr

        VAR[label="VAR\nTYPES: [float]", TYPES="[float]"]
        call42_types [OPTIONAL="t", TYPES="[compatible]", label="TYPE: [compatible]?", shape=rectangle]
        call9_nested_function [label="nested function, TYPES: [compatible]", TYPES="[compatible]", shape=rectangle]
        VAR -> call8_nested_function 
        call9_nested_function -> EXIT_aggr
        aggr_function -> VAR
        VAR -> call42_types
        call42_types -> EXIT_aggr
        
        //==================================================
  }
    
    subgraph ignore {

        "concatenated grouping" -> "concatEl"
        "concatEl" -> "concatenated grouping"
        "single grouping element" -> "GroupingEl"
        "GroupingEl" [label="grouping element"]
        "concatEl" [label="grouping element"]



        EXIT_string -> HAVING [color=none]
        HAVING [label = "HAVING clause"]
        HAVING -> "HAVING conditions"
        "HAVING conditions" -> BoolNot -> AggrBoolExpr
        BoolNot [label = "NOT"]
        "HAVING conditions" -> "atomic condition"
        "HAVING AggrFunc" [label = "aggregate function"]
        "atomic condition" ->"HAVING AggrFunc"
        "atomic condition" -> AggrNot -> "HAVING AggrFunc"
        AggrNot [label = "NOT"]
        "HAVING AggrFunc" -> less
        "HAVING AggrFunc" -> equal
        "HAVING AggrFunc" -> loe
        "HAVING AggrFunc" -> noneq
        "HAVING conditions" -> AggrBoolExpr
        AggrBoolExpr [label = "Bool Expression"]
        AggrBoolExpr -> AggrOr -> SecondCond
        AggrBoolExpr -> AggrAnd -> SecondCond
        AggrBoolExpr -> AggrXor -> SecondCond
        AggrOr [label = "OR"]
        AggrAnd [label = "AND"]
        AggrXor [label = "XOR"]
        SecondCond [label = "HAVING conditions"]
        less [label = "<"]
        equal [label = "="]
        loe [label = "<="]
        noneq [label = "<>"]
        "num val" [label = "numeric value"]
        less -> "num val"
        loe -> "num val"
        equal -> "num val"
        noneq -> "num val"

        "num val" -> "EXIT HAVING"


        "EXIT GROUPING ELEMENT" -> "aggregate function" [color=none]
       
        AggrExpr -> "AGGREGATE WITH ALIAS"
        AggrNone -> "AGGREGATE WITH ALIAS"
        AggrExpr -> "AGGREGATE WITHOUT ALIAS"
        AggrNone -> "AGGREGATE WITHOUT ALIAS"
        "AGGREGATE WITHOUT ALIAS" -> "EXIT AGGREGATE"
        "AGGREGATE WITH ALIAS" -> "EXIT AGGREGATE"

        "NO-GROUPING" -> selectDistinct
        "NO-GROUPING" -> "non-DISTINCT"
        selectDistinct -> "generate projection"
        "non-DISTINCT" -> "generate projection"
        selectDistinct [label = "DISTINCT"]

    }

}
